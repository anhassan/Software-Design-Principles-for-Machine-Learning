# Software Design Principles for Machine Learning

# Introduction

Data Scientists are often accustomed to writing code for proof of concepts or developing prototypes as most of their time is involved in research and lesser part of their time is involved in actual development. Hence, the code they come up with does work well but is not the most optimized version. In production environment it is desired that the code deployed is clean and optimized in order to reduce the cost to change and maintain Machine learning (ML) infrastructure.  However, in order to write production level Machine learning pipelines, it is essential that the code implemented adheres to essential software principles because ML software is software after all and it requires changes and updates. Adhering to software principles not only makes sure that the code implemented is clean and its quality is up to the mark but also reduces the cost of change and also increases the optimal responsiveness to change of machine learning pipelines. This repository demonstrates how easily it is to incorporate software design principles specifically SOLID principles in ML pipelines and how these principles can get violated and cause problem related to robustness when there arises a need for change in the code base.

# Design and Implementation

There are in total 10 scripts(5 pairs) where each pair show cases the violation and implementation of a principle in SOLID software design principle. SOLID is an acronym for the 5 software design principles which increase the software quality by ensuring loose coupling and high cohesion. 

The first principle which denotes the **S** in SOLID is the *Single Responsibility Principle* which states that:
*" A module, a class or a method should be responsible for a single functionality of a software system"*
In other words a class should only have one reason (actor) to change or one class should only implement a single task. *Single Responsibility Principle* violation can be found if a certain class is having to many functionalities which is quite often referred as *God* class. This violation can be resolved by separating out each and every distinct functionality of the *God* class into separate classes. Both the violation and implementation of *Single Responsibility Principle* are shown in `SingleResponsibilityPrincipleViolated.py` and `SingleResponsibilityPrincipleImplented.py` respectively 

The second principle which denotes **O** in SOLID is the *Open/Closed Principle* which states that:
*"Software entities (classes, modules, methods) should be open for extension but closed for modification"*
In other words it means that if there is need to add a new functionality or feature in the code base then there should not be a need to change the existing code but the code should be modular enough that the new functionality can be added as a new entity. *Open/Closed Principle* violation can be found if classes are tightly coupled and changing one part of the code effects multiple entities (classes). This violation also makes the code difficult for testing purposes. A solution to this problem is Polymorphism or making interfaces. Interface generation makes not only makes the code more robust not only in terms of changes but also in terms of additions. Both the violation and implementation of *Open/Closed Principle* are present in `OpenClosedPrincipleViolated.py` and `OpenClosedPrincipleImplemented.py`

The third principle which denotes **L** in SOLID is the *Liskov Substitution Principle* which stated that:
*"If S is a subtype of T, then objects of type T maybe be replaced by objects of type S, without disrupting the program"*
In other words it means that the code base have the flexibility to use any subtypes of a class interchangeably without any hassle. *Liskov Substitution Principle* violation can be found if code base depends upon concrete implementations or if there is a requirement to change code if a subtype changes. This violation can be easily spotted if different subtypes have different method signatures or different argument types. A solution to this problem is to write subtype in such a way their method signatures and high level design remains the same so that the downstream applications or code can use different subtype implementations interchangeably. Both the violation and implementation of *Liskov Substitution Principle* are present in `LiskovSubstitutionPrincipleViolated.py` and `LiskovSubstitutionPrincipleImplemented.py`

The fourth principle which denotes **I** in SOLID is *Interface Segregation Principle* which states that:
*"Code should not depend upon methods it does not use"*
In other words it means that it is better to have multiple specific interfaces rather than a single generic interface. *Interface Segregation Principle* violation can be found if subclasses implement abstract methods they don't even use by use a hack such as raising an exception. This violation can be resolved by either having different interfaces for different purposes rather than a single generic interface encapsulating all the possible functionalities. Note that this is similar to *Single Responsibility Principle* on an interface level. As usual, again the violation and implementation of *Interface Segregation Principle* are available in `InterfaceSegregationPrincipleViolated.py` and `InterfaceSegregationPrincipleImplemented.py`

The fifth and the last principle which denotes **D** in SOLID is *Dependency Inversion Principle* which states that:
*"Classes should depend upon abstractions and not concretions"*
In other words it means that does a class contain an instantiation of an object belonging to a discrete implementation. *Dependency Inversion Principle* violation can be spotted if there is a concrete object creation within say a constructor of a class. This makes code changes without the need to change the downstream code base impossible. A solution to this violation is to use generic interfaces rather than to use particular implementations. Adhering to this principle makes the code loosely coupled and makes unit testing easier. *Dependency Inversion Principle* is very closely related to *Open/Closed Principle* since it makes the code open for extension and closed for modification. Both the violation and implementation of *Dependency Inversion Principle* are present in `DependencyInversionPrincipleViolated.py` and `DependencyInversionPrincipleImplemented.py`

Adhering to these principles renders another big advantage of bringing isolation in different components and hence paving ways for Test Driven Machine Learning (TDML). TDML not only allows us to test our ML components in isolation but also increases the code coverages which helps in generating robust ML pipelines requiring less changes in production. 